### 비트코인이란?

화폐단위. 가상화폐. 송신자가 수진자에게 가치를 전송하는 거래 내에 존재.

분산화된 p2p 시스템 '중앙'서버나 통제소가 없다. 비트코읜은 채굴이라는 과정을 통해 생성됨.  채굴자들은 평균 10분마다 누군가가 지난 10분 동안 발생시킨 거래들에 대해 입증하고 채굴에 성공하는 경우 새로 생성된 비트코인으로 보상받는다.

> 채굴 과정이란 비트코인 거래가 진행되는 동안 수학 문제에 대한 해답을 찾기 위해 서로 경쟁하는 작업. 비트코인 채굴 과정은 화폐 발행 및 어음 결제라는 중앙은행의 역할을 분산하며, 전 세계적으로 경쟁하는 채굴이라는 과정을 통해 중앙은행에 대한 필요성을 대체한다.

* 비트코인의 구성요소

1. 분산화된 P2P 네트워크(비트코인 프로토콜)

1. 공개거래장부(블록체인)
2. 분산화된 수학적 결정론적 통화 발행(분산 채굴)
3. 분산화된 거래 검증 시스템(거래 스크립트)

-비트코인 장부 : 블록체인

* 거래  : 일반적으로 재(財) 또는 서비스를 대상으로 하여 상인과 상인, 또는 상인과 고객 사이에서 이루어지는 매매행위. 

* 비트코인 거래

  비트코인에는 현재 소유자의 공개키(주소)가 포함되어 있다. 사용자 *갑*이 사용자 *을*에게 무언가를 전송할 경우를 보자. *갑*은 *을*의 공개키(주소)를 비트코인에 추가하고 *갑*이 소유한 개인키로 서명한다.[[9\]](https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8#cite_note-9) 그 다음 *갑*은 이 비트코인을 적절한 메시지의 거래 내역으로 [P2P](https://ko.wikipedia.org/wiki/P2P) 네트워크에 방송한다. 나머지 네트워크 노드들은 암호화된 서명과 거래량을 허가하기 전에 입증한다. 거래가 생성되면 누가 거래를 생성했든 자금원의 소유자가 해당거래의 서명을 해야한다. 서명이 완료되면 거래가 유효화되고 돈의 송금에 필요한 모든 정보가 담긴다.

  

- 승인/미승인

`미승인(Unconfirmed)` : 해당 거래가 네트워크에 전송은 되었지만 블록체인이라는 비트코인 거래 장부에는 아직 포함되지 않았음.

`승인(Confirmed)` : 거래가 블록체인에 포함되기 위해서는 채굴자들이 '채굴'을 해야한다. 새로운 블록이 약 10분만에 형성되면 블록 내에 있는 거래 내역들은 네트워크상에서 승인됨. 그 후 소비가 가능. 거래는 발생하자마자 모두가 볼 수 있지만 새롭게 채굴된 블록에 포함되는 경우에만 모두가 '신뢰'한다.

`신뢰` : 비트코인 체제 내에서는 시스템 내의 다른 여러 참가자들의 상호작용을 통해 새로운 속성이 생기면서 신뢰가 쌓이게 된다.

### 비트코인의 작동원리

* 비트코인 시스템의 구성 요소
  - 키가 들어 있는 지갑을 보유한 사용자들
  - 네트워크에 전송되는 거래들
  - 거래내역 전부를 담고 있는 권위있는 장부인 동의 블록체인을 생산해내는 채굴자들

1. 거래

비트코인을 많이 보유한 소유주가 비트코인 일부를 다른 사람에게 전송하는 것을 승인한다고 네트워크에 이야기 해주는 것. 즉, 비트코인의 새로운 소유주는 또 다른 소유주에게로 비트코인이 전송되는 것을 승인하는 다른 거래를 만드는 과정을 반복함으로써 매수한 비트코인을 소비할 수 있다.

거래는 복식부기 장부에 나오는 대변과 차변으로 구성된다. 즉, 각 거래는 하나이상의 '입력값' 즉 비트코인 계좌에서 빠져나가는 차변과, 거래의 또 다른 구성요소로서 하나 이상의 '출력값' 즉 비트코인 계좌로 들어오는 대변으로 구성된다. 입력값과 출력값의 합계가 반드시 동일할 필요는 없지만 출력값의 총합은 입력값으 총합보다 약간 작아야 하며, 이 차이 값은 거래 속에 포함된 '거래 수수료'가 된다.

송금되는 비트코인의 금액(입력값) 각각에 대한 소유권을 소유즈의 디지털 서명을 통해 증명하는 과정이 거래에 포함되며 누구든지 독립적으로 거래를 검증할 수 있다.

* 소비(spending)

이전 거래에서 송금되었던 돈이 비트코인 주소에 의해 확인된 새로운 소유주에게로 전송되는 거래에 서명을 함으로써 이루어지는 작업.

> 거래를 통해 거래 입력값에서 거래 출력값으로 가치가 이동. 입력값은 비트코인의 가치가 발생하는 지점 , 주로 이전 거래의 출력값이다.
>
> 거래 출력값은 키를 이용해서 새로운 소유주에게 비트코인의 가치를 넘겨준다. 예상지출(encumbrance)이라고 불리는 목적지 키는 향후 거래에서 돈을 사용하기 위해 필요한 서명을 만들 때 사용됨. 이와 같이 소유권 사슬을 생성함으로써 가치가 비트코인 주소들 간을 이동하게 된다.

* 거래 유형

  * 하나의 주소에서 다른 주소로 단일 거래가 이루어지는 형태.  이 경우 종종 원 소유주에게 돌려줘야하는 '잔액'이 존재. 이떄 하나의 입력값과 두개의 출력값이 발생.(common transaction)
  * 여러개의 입력값을 하나의 출력값으로 합치는 거래. 이 형태는 실제로 동전과 단위가 작은 지폐가 많이 있는 경우 큰 단위의 지폐 한 장으로 교환하는 행위와 동일. 지불 과정에서 잔액으로 받은 작은 단위의 금액을 정리하기 위해 지갑 어플리케이션에서 때때로 이 유형의 거래가 시행됨.(aggregating transaction)
  * 하나의 입력값을 여러 명의 수신인에게 줄 수 있는 여러 개의 출력값으로 배분하는 형태. 기업체에서 다수의 직원들에게 급여를 지불하는 등 돈을 분배해야 할 경우에 사용.(distributing transaction)

* 비트코인 거래는 거래가 실행되어야 할때 네트워크로 전송하면 된다.

  1. 송신자는 지갑 어플리케이션에 수신자에게 전송하기를 원하는 금액을 지불할 수 있도록 알맞은 입력값을 찾아야 한다. 지갑 어플리케이션 대부분은 지갑 소유주가 보유한 키로 잠겨 있는(지출이 예상되는) '소비되지 않은 거래 출력값(unspent transaction output)' 에 대한 소용량의 데이터베이스를 보유하고 있다.

     > 풀 클라이언트(full client) 를 사용하는 비트코인 지갑 어플리케이션의 경우, 블록체인상에 있는 모든 거래에서 실제로 발생하 소비되지 않은 출력값의 복사본을 보유하고 있다. 이 덕분에 지갑에서 거래 입력값을 생성할 수 있을 뿐만 아니라 정확한 입력값을 가지고 향후 거래를 신속하게 검증할 수 있다. 하지만  풀인덱스 클라이언트의 경우 디스크 공간을 많이 차지하기 때문에 대부분의 사용자 지갑에서는 사용자 본인의 소비되지 않은 출력값만 추적하는 '라이트웨이트 '클라이언트를 가동한다.

  2.  거래 출력값은 해당 가치에 대한 예상지출을 생성하는 스크립트의 형태로 만들어지며 스크립트에 대한 솔루션이 제공되는 경우에만 사용할 수 있다.

  3. 해당 거래는 분산장부(블록체인)의 일부가 되기 위해 비트코인 네트워크로 전송되어야 한다. 

  4. 비트코인 네트워크는 p2p네트워크로, 각각의 비트코인 고객이 여러 다른 비트코인 고객들에게 접속함으로써 네트워크에 참여하게 된다. 비트코엔 네트워크의 목적은 거래내역과 블럭을 참여자 전원에게 전파하는 것이다.

  5. 비트코인 네트워크 노드(다른 고객들)가 이전에는 없던 유효한 거래를 전송받으면 즉시 연결되어 있는 다른 노드로 해당 거래를 전달한다. 이런 과정을 통해 거래는 P2P네트워크를 통해 급속도로 전파되고 몇 초만에 비트코인 네트워크 내에 있는 노드 대부분에게 도달한다.

     

2. 블록

   각 거래들은 `블록`단위로 묶여 있고, 입증해야 할 수학적 계산의 규모가 엄청나지만 입증된 후에는 검증을 위해서 그다지 많은 계산을 하지 않아도 된다.

3. 채굴

   * 채굴 과정은 돈을 새로 바행하는 중앙은행처럼 각 블록 내에서 새 비트코인을 생성한다. 한 블록당 생성되는 비트코인의 양은 고정되어 있고 시간이 지나면서 줄어든다.
   * 채굴 과정은 거래를 담고 있는 블록이 충분한 연산력을 사용하여 승인되었다는 것이 확인되었을 때만 신뢰가 생긴다.

   네트워크로 전송된 거래는 전 세계적으로 분산되어 있는 장부인 블록체인에 올라가기 전에는 검증되지 않는다. 평균적으로 10분마다 채굴자들은 지난 블록까지의 거래 전부가 포함된 새 블록을 생성한다.

   비트코인 네트워크 노드들이 이 상황을 지켜보다가 각 노드가 유지하고 있는 임시 풀(temporary pool)로 이 새로운 거래들을 추가한다.이 임시 풀에는 미검증 거래들이 들어있다. 채굴자들이 새 블록을 만들면서 이 임시풀에서 새 블록으로 미검증 거래들을 추가한 후 새 블록의 유효성을 입증하기 위해 매우 어려운 문제(작업인증)를 풀려고 노력한다.

   거래들이 새 블록에 추가될 때 거래 수수료가 가장 높은 거래부터 우선순위로 추가되고 몇몇 거래는 다른 기준을 바탕으로 추가된다.

4. 블록체인

   *블록 체인*(*block chain*)이라고 불리는 거래내역이 있는데, 이것은 알려진 모든 거래 내역의 목록을 수집해 보관하는 것이다. 블록 체인에서 6회 이상 인정되어야 공식적인 거래가 된다. 각각의 *생성용* 노드들은 인정되지 않은 거래 내역을 전해 듣고 후보 *블록*에 수집한다. 후보 블록은 다른 것과 함께 있는 파일이고 이미 알려져 있는 바로 이전의 유효블록(valid-block)의 암호화 해시를 포함하고 있다. 생성용 노드들은 난이도에 의해 정해진 목표값 이하의 암호화 해시를 생성하기 위해 시행 착오를 반복한다. 노드가 그 해답을 찾으면, 노드는 네트워크의 나머지 노드에게 알린다. 새로 해결된 블록(solved-block)을 받은 노드들은 그것을 허가하기 전에 인증하고 체인에 추가한다.

   결국, 블록체인은 생성자의 주소부터 현재 소유자의 주소까지 모든 암호화 기록을 갖게 된다.그래서 사용자가 이미 사용한 돈을 재사용하려고 하면, 네트워크가 거래를 거부할 수 있는 것이다.

> 비트코인 사용자들은 비트코인 네트워크상에서 일어나는 거래에 대한 소유권을 입증할 수 있는 키를 소유함으로써 해당 가치에 대한 암호를 풀어 소비하고 새로운 수신자에게 전송한다. 비트코인을 소비하고 전적으로 통제하려면 비트코인 사용자들은 거래를 위한 암호를 풀 수 있는 키만 가지고 있으면 된다.
>
> 비트코인은 전 세계적으로 매 10분마다 '투표'를 수행하기 위해 분산연산시스템(작업 증명 알고리즘)을 사용함으로써 분산 네트워크가 각 거래 상태에 대해 합의에 이를 수 있도록 함. 이 과정을 통해 단일 통화 단위가 두번 결제되어 발생하는 이중지불 문제를 손쉽게 해결.

* 거래상태(Transaction Status)

  지갑 생성(해시 주소 생성)  -> 비트코인 수신 or 채굴 -> Transaction 생성(이전 거래, 송금/잔액 설정) -> Transaction 서명 -> Transaction 네트워크 전송 -> 거래 승인 (unspent) -> 새로운 거래를 생성할 때, 이전 거래에서 연결 (spent)

### P2P 네트워크

중앙 서버 없이 각 단말들이 서로 동등한 입장에서 통신을 하는 네트워크. 각 단말은 서버이기도 하면서 동시에 클라이언트가 된다.

* 서버를 준비할 필요가 없고, 각 노드들이 트래픽과 자원을 할당해 부하를 분산시켜줌
* 즉, 노드가 증가하더라도 서비스를 유지할 수 있는 높은 확장성을 갖고 있음
* 새로운 기능을 추가하거나 업데이트를 할 경우 관리가 어려움
* 네트워크 전송시간 때문에 노드간 정보 불일치, 성능저하가 발생하기 쉬움

### 하이브리드 P2P와 퓨어P2P

P2P 시스템을 크게 2가지로 분류하면 각 노드들을 발견하고 탐색하기 위한 인덱스 서버(Index Server)를 사용하는 '하이브리드 P2P' 와 순수하게 노드들만 존재하며, 노드 탐색 등의 기능도 노드들이 알아서 수행하는 '퓨어 P2P' 로 구분할 수 있다.

* 하이브리드 P2P

  각 노드의 정보들이 인덱스 서버에 기록된다. 각 노드들간 데이터를 주고 받는 방식은 P2P로 이루어지지만, 노드들의 검색 및 발견 등은 인덱스 서버를 통해서 이루어진다. 그래서 마치 서버/클라이언트 구조처럼  설계와 관리가 용이하지만 확장성이 떨어지는 단점이 있다. 예를들어, 게임상의 높은 네트워크 성능을 위해 유저간 직접 연결하는 P2P통신을 사용하지만 서로 방을 만들고 검색 , 조인하기 위해서는 인덱스 서버를 활용한다.

* 퓨어 P2P

  모든 노드가 동등한 입장으로 네트워크에 연결되어 있다. 새로운 노드가 추가되는 등의 확장성은 높으나 시스템 전반을 설계하고 관리하기가 어렵다. 또한 각 노드들이 자율적으로 다른 노드들을 발견하고 탐색할 수 있도록 하는 알고리즘을 구현해야하는 문제점이 있다.

### 서버/클라이언트 네트워크

* 서버가 서비스 관리를 집중적으로 수행하기 때문에 시스템의 설계 및 유지가 쉬움. 
* 기능 추가, 버그 수정 등 업데이트 및 관리가 쉬움. 
* 서버 장애 등이 발생할 경우 서비스 전체가 중단됨.

### 구조화 오버레이와 비구조화 오버레이

구조화 오버레이는 각 노드들이 물리적으로 연결되어 있으며, 그에 따라 네트워크 토폴로지(Topology)도 반영되어 있는 네트워크이다. 각 노드들의 ID가 할당되어 있고, 그에 따라 연결되는 대상들도 이미 정해져 있다. 라우팅을 통해 메세지 전송경로가 선택되어 있다. 

 *  메세지를 전송하면 목적지 ID를 향해 효율적으로 전송이 되기 때문에 메세지 	도착 가능성이 높음
*  노드의 확장성이 높음
*  노드 수가 증가하더라도 메세지의 전송 횟수는 크게 늘어나지 않음
*  노드 탐색은 네트워크의 물리적인 구조에 영향을 받아 유연함이 떨어짐

반면 비구조화 오버레이는 서로 물리적으로 연결되어 있지는 않지만, 논리적으로 연결된 것처럼 사용하는 네트워크. 일반적으로 각 가정에서 P2P를 이용하는 경우가 비구조화 오버레이 구조이다. 네트워크 토폴로지가 없으며, 각 노드를 탐색할 때는 탐색메세지를 브로드캐스트하여 주변 노드들에게 확산해나가는 방법을 사용. 그러다보니 특정 노드를 향해 메시지를 전송할 경우 각 노드들간 메세지가 전파되면서 중간에 소실되는 경우가 많으며, 노드 수가 증가할  수록 메세지의 전송횟수가 크게 증가하는 문제점이 있다.

비구조화 오버레이에서 메시지 전송문제를 해결하기 위해, 중간 중간 슈퍼노드를 배치하여 메시지 전송을 효율적으로 하려는 개념도 있다.

### 블록체인의 기술 분류

블록체인의 종류에 따라서 그 특징이 다르기 때문에 분류 또한 다르다. 비트코인과 이더리움 같은 경우는 모든 노드가 동등한 입장에서 네트워크를 형성하기 때문에 퓨어 P2P로 분류가 가능하다. 또한 네트워크 토폴로지 역시 정해지지 않았기때문에 비구조화 오버레이라고 할 수 있다.

하이퍼레저같은 경우는 각 노드마다 그 역할을 다르게 지정할 수 있다. 네트워크 토폴로지가 정해지지 않았기 때문에 비구조화 오버레이이긴 하지만, 각 노드마다 역할을 다르게 하여 슈퍼 노드를 도입할 수 있다. 또한 전용 멤버쉽 서버를 갖고 있어 인덱스 서버 역할을 할 수 있기 때문에 하이브리드 P2P라고 할 수 있다.

### 비트코인 클라이언트

비트코인 시스템의 모든 요소를 포함. 

* 지갑
* 거래장부(블록 전체의 복사본이 들어가있는 거래 검증 엔진)
* P2P 비트코인 네트워크 내의 풀 네트워크 노드 기능

1. 풀 클라이언트(Full Client) = 풀 노드(Full node)

    비트코인 거래 정보를 전부(모든 사용자가 현재까지 진행한 거래내역 전부) 저장하고 비트코인 사용자들의 지갑을 관리하여 비트코인 네트워크상으로 직접 거래를 만들어 낼 수 있다. 이러한 특징은 어떤 서버나 제3자의 서비스와 관계없이 프로토콜의 모든 측면을 처리하는 독립형 이메일 서버와 유사하다.

2. 라이트웨이트 클라이언트

   사용자의 지갑을 저장하긴 하지만 비트코인 거래나 네트워크에 접근하기 위해서는 제3자가 소유한 서버에 의존한다.라이트웨이트 클라이언트의 경우 거래내역 전부에 대한 복제본을 저장하지 않기 때문에 거래 검증을 위해서는 제3자 서버에 의존해야 한다. 이는 네트워크와 소통하기 위해 제3자에게 의존하고 메일함 사용을 위해 메일 서버에 접속하느 독립형 이메일 클라이언트와 유사하다.

3. 웹클라이언트

   웹 브라우저를 통해 접속하며 제3자가 소유한 서버상에서 사용자의 지갑을 저장한다. 이는 전적으로 제3자 서버에 의존하는 웹메일과 유사하다.



### 블록체인

* 추가전용 DB이고 또는 로그 DB. 내용을 추가만 할 수 있고, 삭제 기능은 없다.

* 블록을 주기적으로 생성하고 이를 체인으로 연결한다.

  => P2P네트워크이기 때문에 다수의 피어(채굴자)들이 블록을 누가 만들 것인가를 합의해야한다. 이 때문에, 즉시 처리가 불가능하고 (평균적인) 일정한 시간동안 거래(데이터)를 모아서 거래를 처리하는 방법을 사용한다.

  구체적으로 블록은 '거래의 모음'으로 1)소유권 이전 기록, 즉 거래 기록을 포함하고 또한 2) 거래 위조 방지 등을 위한 헤더부를 포함한다.

  ------

  

### 키,주소,지갑

디지털 키, 비트코인 주소, 디지털 서명 등을 통해 비트코인의 소유권이 성립된다.

### 디지털 키

실제로 네트워크상에 저장되어 있지 않고 사용자가 파일 속, 즉 간단한 데이터베이스인 지갑 속에 생성해서 저장해 둔다. 사용자의 지갑 속에 들어 있는 디지털키는 비트코인 프로토콜과는 완전히 독립되어 있고 블록체이에 대한 참조나 인터넷 접근 없이 사용자의 지갑 소프트웨어가 생성하고 관리할 수 있다. 키는 공개키와 개인키 이렇게 한 쌍으로 구성되어 있다.

* 공개키 : 은행의 계좌번호와 유사.
* 개인키 : 비밀PIN 혹은 본인 계좌를 관리하기 위해 수표에 하는 서명과 유사

대부분의 경우 공개키와 비밀키는 지갑 파일 내부에 저장되고 비트코인 지갑 소프트웨어를 이용해서 관리.

1. 공개키의 암호법과 암호화폐

비트코인은 사용하는 공개키 암호법으로 `타원곡선 곱셈함수`를 기본 토대로 삼고 있다.

비트코인에 접근하는 권한을 주는 한 쌍의 키를 생성하기 위해 공개키 암호법을 활용.

공개키는 비트코인을 전송받을 때 사용되며, 개인키는 전송받은 비트코인을 소비하기 위해 거래에 서명을 할 때 사용.

비트코인을 소비하는 경우, 현재의 비트코인 소유주가 거래 내에서 공개키와 서명(매번 다르지만 동일한 개인키로부터 생성)을 제시하면 해당 금액의 비트코인을 소비할 수 있다. 공개키와 서명을 제시하게 되면 비트코인 네트워크 내에 잇는 모든 사람들이 그 거래를 검증하고 유효한 거래로 받아들일 수 있게 된다. 동시에 비트코인을 전송하려는 사람이 전송 당시에 비트코인을 보유하고 있었는지 여부도 확인 가능하다.

2. 개인키와 공개키

비트코인 지갑에는 상으로 구성된 키가 여러 개 들어 있고, 각각의 쌍은 개인키와 공개키로 구성되어 있다. 개인키는(k) 숫자로 구성되어 있으며 대개 무작위로 숫자를 추출한다. 일방 암호함수인 타원곡선 곱셈함수를 이용해서 개인키로부터 공개키(K)를 생성한다 . 그리고 일방 암호해시함수를 이용해서 공개키(K)로부터 비트코인주소(A)를 생성한다.

![1533703510299](C:\Users\user\AppData\Local\Temp\1533703510299.png)

[출처] Mastering Bitcoin 그림 4-1

3. 개인키

개인키는 무작위로 추출한 단순한 숫자로 구성되어 있다. 거래에서 사용되는 돈의 소유권을 증명하게 되면 비트코인을 소비할 수 있게 되는데, 이때 필요한 서명을 하기 위해 개인키를 사용한다. 개인키를 한번 분실하게 되면 다시 찾을 수가 없고 해당 개인키로 묶여있는 돈 역시 영원히 찾을 수 없다.

 * 무작위로 뽑은 숫자를 이용해서 개인키 생성하기

   난수생성기를 이용해 256비트의 엔트로피(무작위성)을 만들어낸다.개인키는 1에서 n-1 사이의 어떠한 숫자로도 구성될 수 있다. 여기에서 n은 비트코인에 사용된 타원곡선의 위수(order)라고 정의된 상수이다. 이러한 키를 생성하기 위해서 무작위로 256비트의 숫자를 선택하고 이 숫자가 n-1보다 작은지 체크한다.

    암호학적으로 안전한 엔트로피소스를 통해 수집된 무작위 비트 문자열중에서 크기가 큰 것들을 SHA256해시 알고리즘에 넣으면 편리하게 256비트의 숫자를 생성할 수 있다.  결과값이 n-1보다 작으면 알맞은 개인키가 생성됐다고 보면 된다. (n-1보다 크면 다른 난수를 이용해서 다시 한번 시도하면 된다.)

   

4. 공개키

    공개키는 타원곡선 곱셈 함수를 이용해서 개인키로부터 계산되며, 그 과정을 거꾸로 진행할 수는 없다.

5. 타원곡선암호법

   ![1533705443540](C:\Users\user\AppData\Local\Temp\1533705443540.png)

6. 공개키 생성하기

     *  무작위로 생성된 숫자인 k라는 개인키를 출발점으로 해서 k값에 곡선위에서 미리 정해진 값인 `생성포인트 G`를 곱해서 곡선상의 다른 곳에 위치한 포인트를 얻는다. 바로 이 포인트가 공개키인 K가 된다.  (K = k *G, K:공개키/k:개인키/G:생성포인트)
*  생성포인트가 모든 비트코인 사용자들마다 항상 동일하기 때문에 개인키 k에 G를 곱하게 되면 항상 동일한 값의 공개키 K가 나오게 된다. 계산이 한 방향으로만 작용하기 때문에 비트코인주소(K값에서 파생)는 누구와도 공유할 수 있지만 사용자의 개인키(k)는 공유하지 않는다.
*  우리의 목적은 생성포인트 G에 대해서 여러 개의 kG를 찾는 것이다. G를 곡선에 대입한 후 계속해서 k번 더하는 과정은 동일하다. 곡선상 점을 대입시켜 해당 포인트에 대한 접선을 그려서 곡선과의 교차점을 찾고 x축에 대칭시킨다.
*  아래 그림은 곡선상에서 기하학적인 방법을 통해 G,2G,4G를 구하는 과정이다.

![1533706150992](C:\Users\user\AppData\Local\Temp\1533706150992.png)

<키포맷>

개인키와 공개키는 여러 개의 다른 포맷으로 표현될 수 있다. 겉으로는 달라보이지만 모두 동일한 숫자를 암호화한 것이다. 이러한 포맷들은 사람들이 키를 읽고 실수 없이 입력하기 위해 주로 사용된다.

* 개인키 포맷

![1533713956888](C:\Users\user\AppData\Local\Temp\1533713956888.png)

* 공개키 포맷

  공개키는 한 쌍의(x,y) 좌표로 구성된 점으로, 타원곡선상에 존재한다. 공개키는 접두부 `04`와 그 뒤에 따라 나오는 256비트의 숫자 2개로 구성되어 있으며, 숫자 중 하나는 포인트의 x축에 다른 하나는 y축에 있다. 접두부 `04`는 비압축 공개키와 `02`혹은 `03`으로 시작하는 압축 공개키를 구분하기 위해 사용된다.

   - 압축 공개키

  거래크기를 줄이고 비트코인 블록체인 데이터베이스를 저장하는 노드상 디스크 공간을 절약하기 위해서 압축 공개키가 비트코인에 도입. 

  ![1533714215710](C:\Users\user\AppData\Local\Temp\1533714215710.png)

  위 식에서 y값의 부호가 짝수일 경우엔 접두부를 `02`로 음수일 경우엔 접두부를 `03`으로 압축공개키를 저장해서 소프트웨어가 x좌표로부터 y좌표를 정확하게 추론하고 공개키를 해당 포인트의 좌표로 다시 풀 수 있도록 한다.

  압축공개키는 동일한 개인키에 대응한다. 이는 동일한 개인키로부터 생성되었다는 것을 뜻한다.

  - 비압축 공개키

  대부분의 거래에는 비트코인 소유주의 자격을 검증하고 비트코인을 소비하는 데 필요한 공개키가 포함되어 있다. 각각의 공개키는 520비트(접두부/+x/+y)의 공간이 필요하다. 그래서 블록당 수백개의 거래가 증가하면, 즉 매일 수만 개의 거래가 생겨나면 블록체인에 어마어마한 크기의 데이터가 합쳐지게 된다.  비압축 공개키는 `04`를 접두부로 쓴다.

### 디지털 서명

모든 비트코인 거래에는 블록체인에 포함되기 위해 유효한 서명이 필요하며, 이러한 서명은 유효한 디지털 키가 있어야 생성될 수 있다. 따라서 디지털 키의 복사본만 가지고 있으면 누구나 해당 계좌에서 비트코인을 관리할 수 있다.

### 비트코인 주소

비트코인 거래에 있어서 비트코인  수취인의 공개키는 `비트코인 주소`라고 불리는 디지털 지문으로 표현.대부분의 경우 비트코인 주소는 공개키로부터 생성되며 공개키에 대응한다. 하지만 모든 비트코인 주소가 공개키로부터 생성된 것은 아니다. 수취인의 스크립트 등이 공개키 역할을 하기도 한다. 비트코인 주소는 수표처럼 돈의 수취와 관련된 정보를 요약해서 보여줌으로써 비트코인 거래 시 송금처를 마음대로 지정할 수 있다. 즉, 단 하나의 지급 수단으로도 개인계좌나 기업 계좌, 청구서에 대한 지불이나 현금거래 모두가 가능하다.

* 비트코인 주소는 숫자와 문자로 구성된 문자열로, 여러분에게 돈을 전송하고자 하는 어떤 누구와도 공유할 수 있다. 공개키로부터 생성된 주소는 숫자와 글자의 조합으로 이루어져 있고 숫자 '1' 로 시작한다. 
* 비트코인 주소는 개인키 및 공개키 쌍을 보유한 소유주를 나타낼 수 있고, 지불스크립트 등  여러 다른 대상을 나타낼 수도 있다.
* 비트코인 주소를 공개키로부터 생성할 때는 일방 암호화 해싱을 사용한다. 해시 알고리즘은 임의 크기의 입력값으로부터 지문 혹은 '해시 값'을 생성해 내는 일방 함수다.  
* 공개키로부터 비트코인 주소를 만드는 데 사용되는 알고리즘은 '보안 해시 알고리즘(SHA)'과 'RACE Integrity Primitives Evaluation Message Digest(RIPEMD)'
* SHA256

![1533711030413](C:\Users\user\AppData\Local\Temp\1533711030413.png)

[출처 : http://www.bitweb.co.kr/news/view.php?idx=388]

SHA(Secure Hash Algorithm)은 안전한 해시 알고리즘으로 가장 최근에 나온 알고리즘일수록 해시 문자열의 길이가 길고 강력하다는 특징이 있다.

SHA-256은 256비트로 구성되너 64자리 문자열을 반환한다. 산술적으로 계산했을 때 256비트는 2의 256제곱만큼 경우의 수를 만들 수 있다.

<블록체인 속의 SHA-256>

채굴은 기술적으로 볼 때 '하나의 블록을 형성하여 블록체인의 길이를 연장하는 행위'이다. 이 때 블록을 형성하는 방법은 현재 블록에서 정해진 난이도를 만족하는 정답 값을 찾는 것이다. 흔히 이 정답 값을 논스(Nonce)라고 하며 논스 값은 사실상 Brute-Forcing 으로만 찾을 수 있다.

![1533711717391](C:\Users\user\AppData\Local\Temp\1533711717391.png)

[출처 : http://www.bitweb.co.kr/news/view.php?idx=388]

위 그림을 보면 기본적으로 블록체인의 난이도가 1000000임을 확인할 수 있다. 이는 블록이 형성되려면 ‘현재 해시’의 값이 1000000 이하의 값이 되어야 한다는 의미이다. 첫 번째 블록의 정답(Nonce) 값이 3849356으로 되어있는데, 3849356을 해시 알고리즘의 입력으로 넣고 돌렸을 때 그 결과가 A34983E로 1000000보다 작아서 채굴(Mining)에 성공한 것이라고 볼 수 있다. 물론 해시 값이 1000000보다 작기만 하면 무엇이든지 정답이 될 수 있다. 채굴에 성공한 이후에는 다음 블록으로 현재의 해시 값이 넘어간다. 두 번째 블록부터는 (이전 해시 + 정답)을 해시한 값이 1000000보다 작아야 한다. 정답 값을 찾을 확률은 난이도에 정비례하며 ‘이전 해시’의 값을 ‘현재 해시’를 구하는 데 활용하는 이유는 블록체인을 변조로부터 방어하기 위해서이다. 

![1533711795127](C:\Users\user\AppData\Local\Temp\1533711795127.png)

[출처 : http://www.bitweb.co.kr/news/view.php?idx=388]

예를 들어 위와 같이 두 번째 블록의 데이터가 변조되었다고 해보자. 두 번째 블록에서 8598493 외에도 9871223이라는 정답이 존재하여 위와 같이 해시 값이 난이도를 만족한다고 가정한다. 하지만 특정한 블록은 이전 블록의 해시 값을 토대로 새로운 해시를 만들어낸다는 점에서 두 번째 블록의 뒤로 이어진 모든 블록은 이로 인해 해시 값이 완전히 바뀌어버린다. 세 번째 블록부터 시작하여 존재하는 모든 블록들의 해시 값이 바뀌며 대부분의 블록은 난이도 1000000을 만족하지 못할 것이다. 결과적으로 악의적인 공격자가 특정한 거래 내역을 바꾸기 위해서는 특정한 블록부터 시작해 뒤쪽의 모든 블록의 정답(Nonce) 값을 새롭게 찾아야 한다.

 위와 같이 블록체인은 블록마다 해시 데이터가 긴밀하게 연결되어 블록이 생성될수록 더욱 견고해진다. 물론 가장 뒤쪽에 있는 몇 개의 블록은 상대적으로 해킹당할 가능성이 높다. 그래서 상당수 거래소 및 지갑 소프트웨어에서는 입금이 발생한 뒤에도 블록이 최소한 몇 개는 더 생성되어야 비로소 ‘완전히’ 입금이 이루어졌다고 판단한다. 또한 위 예시는 저자가 간단히 만들어본 것으로 해시 결과 값의 길이가 매우 짧지만 실제 블록체인에서는 SHA-256 등을 사용해 이보다 훨씬 긴 해시 결과 문자열을 가진다. 혹은 더욱 복잡한 자체 알고리즘을 적용하곤 한다. 

따라서 경제적인 측면에서 보았을 때 블록을 변조하려고 노력하는 것보다 성실히 채굴(Mining)에 임했을 때 더욱 많은 수익을 얻을 가능성이 높다. 흔히 암호화폐 관련 해킹이 발생했다고 하면 개인 PC, 거래소 서버, 계정 정보 등을 해킹당한 사례가 대부분이며 블록체인이 해킹당하는 일은 드물다. 물론 취약한 알고리즘을 적용한 몇몇 암호화폐들은 블록체인 자체를 해킹당한 이력이 있다. 다만 그들 중 상당수는 이미 하드포크(Hard Fork) 등의 기법을 이용해 재탄생되었다. 이제 위 블록체인 프로토타입에 거래 내역(Transaction)의 개념을 더해보자. 

![1533712131915](C:\Users\user\AppData\Local\Temp\1533712131915.png)

실제 블록체인에서는 위와 같이 거래 내역을 저장한다. 각 블록은 새로운 블록이 만들어질 때까지 발생한 모든 거래 내역을 기록한다. 위 그림을 통해 첫 번째 블록이 생성되고 두 번째 블록이 생성되기까지 3번의 거래가 발생했음을 알 수 있다. 이 때 하나의 블록에서 ‘현재 해시’ 값을 생성할 때는 해당 블록에 기록된 거래 내역 데이터들이 반영된다. 거래 내역에서 한 글자만 바꾸어도 해시 값이 완전히 바뀌므로 한 번 성사된 거래는 돌이키기 어렵다. 만일 거래 내역 중에서 특정한 데이터를 변조하려고 하면 이후 존재하는 모든 블록들의 해시 값까지 변경된다. 

![1533712170253](C:\Users\user\AppData\Local\Temp\1533712170253.png)

한 번 A, B, C라는 세 채굴자가 블록체인 생성에 기여하고 있다고 가정해보자. 이 때 위 그림과 같이 채굴자 C가 블록체인의 두 번째 블록에 있는 ‘A가 C에게 25코인을 송금’했다는 데이터를 ‘A가 C에게 2500코인을 송금’했다는 데이터로 조작을 하면 어떻게 될까? 이 경우 데이터를 조작하자마자 두 번째 블록의 ‘현재 해시’ 값이 변경되어 새로운 정답(Nonce) 값을 찾지 않는 이상 성공적으로 해당 블록을 변조시킬 수 없다. 행여나 두 번째 블록의 새로운 정답 값을 찾았다고 해도 두 번째 블록 이후의 모든 블록의 해시 값이 변경된 상태이므로 이후 블록들에 대한 정답 값도 찾아야 할 것이다. 그러므로 사실상 장부를 변조하는 것은 불가능하다.

더불어 채굴자 C가 가장 최근의 몇 개 블록에 대한 변조에 성공했다고 하더라도 동일한 네트워크에 있는 A와 B가 가지고 있는 블록체인과 그 형태가 다를 것이다. 따라서 A와 B에게는 C의 변조된 장부가 올바른(Correct) 장부라고 받아들여지지 않는다. 블록체인은 이러한 방어 기술을 내재한다는 점에서 강력하다. 다만 현재의 상당수 블록체인은 컴퓨터 연산 능력을 합의(Consensus)의 기준으로 삼고 있다. 이 경우 채굴자 C의 네트워크 장악력이 50%를 초과한다면 채굴자 C의 장부가 올바른 장부로 받아들여질 가능성이 있다. 하지만 방대한 채굴 네트워크에서 일개 세력의 연산 능력이 50%를 초과하는 것 또한 사실상 불가능하다.

한마디로 블록체인은 해시(Hash)를 통해서 그 무결성이 입증되며 공격자로부터 안전하게 유지될 수 있다.

[출처 : [http://www.bitweb.co.kr/news/view.php?idx=388](http://www.bitweb.co.kr/news/view.php?idx=388#) ]

* RIPEMD160

임의의 길이의 메시지에서 160비트의 메시지 요약을 생성하며, 32비트 연산에 최적화.

![1533712554399](C:\Users\user\AppData\Local\Temp\1533712554399.png)

![1533712578208](C:\Users\user\AppData\Local\Temp\1533712578208.png)

![1533712629844](C:\Users\user\AppData\Local\Temp\1533712629844.png)

![1533712669405](C:\Users\user\AppData\Local\Temp\1533712669405.png)

[출처 :https://m.blog.naver.com/PostView.nhn?blogId=stop2y&logNo=221158642741&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F ]



> 공개키 K를 가지고 SHA256 해시를 산출한 후 그 결과값의 RIPEMD160해시를 산출하면 160비트(20바이트) 크기의 숫자가 생성된다.
>
> `A(Address) = RIPEMD160(SHA256(K))`
>
> 비트코인 주소는 공개키와 똑같지 않다. 비트코인 주소는 일방 함수를 사용해서 공개키로부터 생성된 것이다.

비트코인 주소는 거의 항상 'Base58Check' 라는 인코딩을 통해서 사용자들에게 제공된다. Base58Check는 58개의 문자(Base58)와 검사합(checksum)을 이용해서 사람이 읽을 수 있는 문자로 바꾸어 주고 비슷한 모양의 문자를 쓰지 않음으로써 혼란을 방지하며 거래의 표기나 항목에 대한 에러가 발생하지 않도록 해준다.

예를들어 , 비트코인 주소 , 개인키, 암호화키, 스크립트 해시 등을 사용자가 읽고 정확하게 숫자를 입력할 필요가 있을 때 사용된다.

* 공개키에서 비트코인 주소까지 : 공개키가 비트코인 주소로 전환되는 과정

  

![1533713932000](C:\Users\user\AppData\Local\Temp\1533713932000.png)

------

### 지갑

지갑은 개인키를 담는 곳으로, 대개 구조화된 파일이나 간단한 데이터베이스 형태로 구현. 키를 제작하는 또 다른 방법은 `결정적 키 생성법(deterministic key generation)`이다. 

일반적으로 일방해시함수(one-way-hash function)를 이용해서 이전 개인키로부터 새로운 개인키 각각을 생성하며, 이 개인키들은 차례대로 연결된다. 이 배열을 계속 만들어내는 최초 개인키('seed ' 또는 'master key')만 있으면 배열상의 모든 개인키를 생성해 낼 수 있다.

> 각 사용자들은 키가 들어 있는 지갑을 보유하고 있다. 실제로 지갑들은 개인/공개키 쌍이 담겨  있는 열쇠고리라고 할 수 있다.  사용자들은 키를 이용해서 서명함으로써 자신들이 거래 출력값(비트코인)을 소유하고 있음을 입증한다.비트코인은 거래 출력값의 형태로 블록체인 내에 저장되어 있다.



